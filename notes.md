# Chapter 2 Creating your first database and table
- sql:
    - define table structure and tables' relationship
    - query data
- Database builders prefer to organize data using separate tables for each main entity the database manages in order to reduce redundant data
- column datatype
    - `bigserial`: a special integer type that will auto-increment when a new row is added
- Text and dates (use `YYYY-DD-MM`) require quotes; numbers, including integers and decimals, don’t require quotes 
- `INSERT 0 6`: insert 6 lines, you can ignore 0 here due to legacy
- code format
    - UPPER CASE keywords and data types
    - use lowercase_and_underscores for object names, such as tables and column names 
- use DISTINCT to find bad data: e, if a school name is spelled more than one way, those spelling variations will be easy to spot and correct, especially if you sort the output; use DISTINCT on multiple columns to find distinct pairs (question: `For each x in the table, what are all the y values?`)
- Using LIKE and ILIKE with WHERE
    - ILIKE 'b%', ILIKE 'ba_er'

# Chapter 4 Understanding Data Types
- Characters
    - char, varchar, text
    ```
    # export function
    CREATE TABLE char_data_types (
 	char_column char(10),
 	varchar_column varchar(10),
 	text_column text
    );

    INSERT INTO char_data_types
    VALUES
        ('abc', 'abc', 'abc'),
        ('defghi', 'defghi', 'defghi');

    COPY char_data_types TO 'C:\Users\Lenovo\Desktop\SQL\practical-sql-2\Chapter_04\typetest.txt'
    WITH (FORMAT CSV, HEADER, DELIMITER '|');

    # result 
    char_column|varchar_column|text_column
    abc       |abc|abc
    defghi    |defghi|defghi
    ```
- Numbers
    - Integers
        - smallint(2b +/- 2**15), integer(4b), bigint(8b), if insert out of range, will have `out of range` error
            - auto-increment
                - add `GENERATED ALWAYS AS IDENTITY` (cannot insert id) Vs `GENERATED BY DEFAULT AS IDENTITY` (can still insert id)
                    - some scenarios auto-increment will create gaps in the sequence of numbers in the column. e.g. If a row is deleted, the value in that row is never replaced. Or, if a row insert is aborted (due to a bug),the sequence for the column will still be incremented.
                - special ones (similar to `GENERATED BY DEFAULT AS IDENTITY`): smallserial(2b 1~2**15), serial(4b), bigserial(8b)
    - Decimals
        - decimals(precision, scale): max digits on decimal left = precision - scale,  scale = fixed decimal digits, e.g. decimal(5, 4), then it means it will be a number less than 10 with 4 decimal digits. If u miss precision and scale tgt, it will be decimal(147455, 16383)
        - real (4b, 6 decimal) vs double precision (8b, 15 decimals): not very accurate
    - 3 rules
        - first use bigint, then use decimals (set precision large enough)

- Date
    - timestamp (8b): TIMESTAMP WITH TIME ZONE(a.k.a timestamptz)
    - date (4b)
    - time (8b)
    - interval (16b)

- Json:
    - json
    - jsonb: support indexing

- Tips:
    - expressions (computed columns): `SELECT timestamp_column - interval_column AS new_date FROM date_time_types`

# Chapter 5  Importing and Exporting Data
- postgresql doesn't use header now, so we need to exclude it when importing
- text qualifier: default as double quotes. enclose a column that includes the delimiter character
    - if Postgresql finds 2 consecutive text qualifiers inside a double-quoted column, it will remove one
    ```sql
    CREATE TABLE us_countries_2010 (
        geo_name VARCHAR(90),
        state_us_abbreviation VARCHAR(2),
        ...
    ) 

    COPY us_countries_2010 (geo_name, ...)
    FROM 'C:\..'
    WITH (FORMAT CSV, HEADER, DELIMITER ',')
    WHERE state = 'Alaska';
    ```
- [primary key](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-PRIMARY-KEYS): A primary key constraint indicates that a column, or group of columns, can be used as a **unique and not null** identifier for rows in the table. A table can have at most one primary key. or example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.
- you can delete the content of table by ```DELETE FROM supervisor_salaries```, but this wont reset the auto-increment id columns. If you want to drop the table, use ```DROP TABLEs```
- temporary table: exists only during current connection session. used to perform intermediary operations for data pipeline
```sql
CREATE TEMPORARY TABLE supervisor_salaries_temp
    (LIKE supervisor_salaries INCLUDING ALL);  
-- INCLUDING ALL means include index and indentities
COPY supervisor_salaries_temp (town, supervisor, salary)
FROM `C:\...`
WITH (FORMAT CSV, HEADER);
INSERT INTO supervisor_salaries (town, country, supervisor, salary)
    SELECT town, 'Millis', supervisor, salary 
    FROM supervisor_salaries_temp
DROP TABLE supervisor_salaries_temp
```

# Chapter 6 Basic Math and Stats with SQL
- With PostgreSQL, you can omit the table name and perform simple math and string operations using SELECT. e.g SELECT 1 + 1
 - array constructor and median
 ```sql
 SELECT percentile_count(ARRAY[0.25, 0.5, 0.75])
 WITHIN GROUP(ORDER BY pop_est_2019) AS quantiles
 FROM us_countires_2019;
 ```
- foreign key: require its value already exists in the column it references. can refer to any column with unique value
- why store in several database?
    - save space by not repeating lengthy strings
    - easier to manage, can only change one part
- filter NULL: WHERE col IS (NOT) NULL
- concatenate methods
    - UNION (unique only) Vs UNION ALL (support duplicate)
    - INTERSECT
    - EXCEPT

# Chapter 8 Table Design that works for you
- Naming Convention
    - use plural noun for table names
    - use snake name
- Constraints
    - 2 types:
        - table constraint
            - `CONSTRAINT {constraint_name} {SQL CONSTRAINT KEYWORD} [table_name](column, [,..])`
        - column constraint
    - tips
        - use GENERATED ALWAYS AS IDENTITY keyword to a column so that the column 1) does not need to insert value 2) will auto insert value   
        ```sql
        <!-- OVERRIDE IDENTITY COLUMN -->
        INSERT INTO surrogate_key_example 
        OVERRIDING SYSTEM VALUE 
        VALUES (4, 'Chicken Coop', '2021-09-03 10:33-07'); 
        
        <!-- OVERRIDE IDENTITY COLUMN START NUMBER -->
        ALTER TABLE surrogate_key_example ALTER COLUMN order_number 
        RESTART WITH 5; 
        
        <!-- NORMAL USE -->
        INSERT INTO surrogate_key_example (product_name, order_time) 
        VALUES ('Aloe Plant', '2020-03-15 10:09-07');
        ```
    - several constraints
        - PRIMARY KEY
        - FOREIGN KEY: when you add foreign key, the primary key it references must exist in the reference table. when you delete primary key, you also need to delete all its corresponding foreign keys. (use ON DELETE CASCADE to do so)
        ```sql
         CREATE TABLE licenses ( 
            license_id text, 
            first_name text, 
            last_name text, 
         CONSTRAINT licenses_key PRIMARY KEY (license_id) 
        ); 
        <!-- Deleting a row in licenses should also delete all related rows in -->
        <!-- registrations. This allows us to delete a driver’s license without first -->
        <!-- having to manually remove any registrations linked to it. It also maintains -->
        <!-- data integrity by ensuring deleting a license doesn’t leave orphaned rows in -->
        <!-- registrations -->
        CREATE TABLE registrations ( 
            registration_id text, 
            registration_date timestamp with time zone, 
            license_id text REFERENCES licenses (license_id) ON DELETE CASCADE, 
            CONSTRAINT registration_key PRIMARY KEY (registration_id, 
        license_id) 
        ); 
        ```
        - CHECK
        ```sql
        CREATE TABLE check_constraint_example ( 
            user_id bigint GENERATED ALWAYS AS IDENTITY, 
            user_role text, 
            salary numeric(10,2), 
            CONSTRAINT user_id_key PRIMARY KEY (user_id), 
            CONSTRAINT check_role_in_list CHECK (user_role IN('Admin', 
        'Staff')), 
            CONSTRAINT check_salary_not_below_zero CHECK (salary >= 0 AND salary<=1000000000>) 
        );
        ```
        - UNIQUE: compared to PRIMARY KEY, UNIQUE column can accept NULL
        - NOT NULL
    - ADD OR REMOVE constraints
    ```sql
    ALTER TABLE not_null_example DROP CONSTRAINT student_id_key; 
    ALTER TABLE not_null_example ADD CONSTRAINT student_id_key PRIMARY KEY (student_id); 
    ALTER TABLE not_null_example ALTER COLUMN first_name DROP NOT NULL; 
    ALTER TABLE not_null_example ALTER COLUMN first_name SET NOT NULL;
    ```
- (B-tree) index: can be applied to multiple columns. a seperate data structure that the database manages
    - how to add?
        - `PRIMARY KEY` or `UNIQUE` will auto create index
        - `CREATE INDEX {index name} ON {table_name} ({column_name}[,...])`
    - useful for data that can be ordered and searched using equality and range and LIKE if there is no wildcard at the beginning of the string (e.g. `WHERE chips LIKE 'Dorito%'`)
    ```sql
    -- Listing 8-13: Benchmark queries for index performance using EXPLAIN ANALYZE
    EXPLAIN ANALYZE SELECT * FROM new_york_addresses
    WHERE street = 'BROADWAY';

    CREATE INDEX street_idx ON new_york_addresses (street);
    DROP INDEX street_idx;
    ```
    - what columns to use?
        - Foreign Keys (speed up join and delete cascade)
        - columns you’ll use in table joins
        - Add indexes to columns that will frequently end up in a query WHERE clause.
 
 # Chapter 9 Extracting Information By Group and Summarizing
 - count
    - count(*): return row numbers, **include NULL**
    - count({colname}): return **NOT NULL** values in a column
    - count(DISTINCT {colname}): return **distinct NOT NULL values** in a column
- GROUP BY (== DISTINCT)
- tips:
    - first `WHERE` then `JOIN` then `GROUP BY` then `SELECT` then `ORDER BY`
- HAVING Vs WHERE
    - aggregate functions, such as sum(), can’t be used within a WHERE clause because they operate at the row level, and aggregate functions work across rows. The HAVING clause places conditions on groups created by aggregating
    - **HAVING wil filter out the whole group rather than some records**

# Chapter 10 Inspecting and Modifying Data
- Data interview, e.g. (use GROUP BY)
    - missing data
    - misspelling data
- Modify Table, Column and Data
    - command 1: start with `ALTER TABLE`, then paired with `ADD COLUMN`, `ALTER COLUMN`, `DROP COLUMN`
    ```sql
    ALTER TABLE table ADD COLUMN column data_type;
    ALTER TABLE table DROP COLUMN column;
    ALTER TABLE table ALTER COLUMN column SET DATA TYPE data_type;
    ALTER TABLE table ALTER COLUMN column SET NOT NULL;
    ALTER TABLE table ALTER COLUMN column DROP NOT NULL;
    ```
    - command 2: start with `UPDATE`, then paired with `WHERE`
    ```sql
    -- set value could be column_name 
    UPDATE table 
    SET column_a = value_a, column_b = value_b 
    WHERE criteria;

    -- DO NOT UNDERSTAND: UPDATE table 
    UPDATE table 
    SET column = (SELECT column 
                  FROM table_b 
                  WHERE table.column = table_b.column) 
    WHERE EXISTS (SELECT column 
                  FROM table_b 
                  WHERE table.column = table_b.column);
    
    ALTER TABLE meat_POULTRY_EGG_ESTABLISHMENTS
    ADD COLUMN inspection_deadline timestamp with time zone

    -- WHERE EXISTS and WHERE here is like join, help to update the value across tables    
    UPDATE meat_poultry_egg_establishments establishments
    SET inspection_deadline = '2022-12-01 00:00 EST'
    WHERE EXISTS (SELECT state_regions.region FROM state_regions WHERE establishments.st = state_regions.st AND state_regions.region='NEW ENGLAND');

    ```
    - Viewing Modified Data with RETURNING, can be paired with `UPDATE`, `INSERT`, `DELETE FROM`
    ```sql
    UPDATE table 
    SET column_a = value 
    RETURNING column_a, column_b, column_c;
    ```
    - Create backup tables:  Indexes are not copied when creating a table backup using the
    CREATE TABLE statement. If you decide to run queries on the backup, be sure to create a separate index on that table.
    ```sql
    CREATE TABLE meat_poultry_egg_establishments_backup AS SELECT * FROM meat_poultry_egg_establishments;
    ```
    - tips:
        - `IS DISTINCT FROM`(treat NULL as known and will only return true/false) Vs `<>` (a comparison that includes a NULL will return NULL)
- Delete data
    - can delete table/database/rows/columns
        - rows: `DELETE FROM table_name WHERE expressions;` or `TRUNCATE table_name RESTART IDENTITY`
        - columns: `ALTER TABLE table_name DROP COLUMN column_name`
        - table: `DROP TABLE table_name`
- Use [transaction](https://www.postgresql.org/docs/current/tutorial-transactions.html) to save or revert changes (atomic operation)
    - you can run by step inside the transaction block, but none of your changes will be visible to other database until you commit or rollback
    ```sql
    START TRANSACTION
    UPDATE meat_poultry_egg_establishments
    SET company='ARGO Merchants Oakland LLC'
    WHERE company='ARGP Merchants Oakland, LLC';

    SELECT company
    FROM meat_poultry_egg_establishments
    WHERE company LIKE 'ARGP%'
    ORDER BY company;
    ROLLBACK;
    ```
- Improving performance when updating large tables
    - when you add new columns, you should copy to a new table and rename the table; if you only add column, then it will create a new version of existing row each time a value is updated, but it does not delete the old version, thus the table size will increase (FIXME: confusing)

